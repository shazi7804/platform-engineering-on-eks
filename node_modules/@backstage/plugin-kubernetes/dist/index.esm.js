import { kubernetesApiRef, kubernetesAuthProvidersApiRef, KubernetesBackendClient, kubernetesProxyApiRef, KubernetesProxyClient, KubernetesAuthProviders, kubernetesClusterLinkFormatterApiRef, getDefaultFormatters, KubernetesClusterLinkFormatter, DEFAULT_FORMATTER_NAME, useKubernetesObjects, DetectedErrorsContext, ErrorPanel, ErrorReporting, Cluster } from '@backstage/plugin-kubernetes-react';
export * from '@backstage/plugin-kubernetes-react';
import { createRouteRef, createPlugin, createApiFactory, discoveryApiRef, identityApiRef, gitlabAuthApiRef, googleAuthApiRef, microsoftAuthApiRef, oktaAuthApiRef, oneloginAuthApiRef, createRoutableExtension } from '@backstage/core-plugin-api';
import React from 'react';
import { useEntity, MissingAnnotationEmptyState } from '@backstage/plugin-catalog-react';
import { Routes, Route } from 'react-router-dom';
import { Grid, Typography, Button } from '@material-ui/core';
import { detectErrors } from '@backstage/plugin-kubernetes-common';
import { Page, Content, Progress, EmptyState } from '@backstage/core-components';

const rootCatalogKubernetesRouteRef = createRouteRef({
  id: "kubernetes"
});
const kubernetesPlugin = createPlugin({
  id: "kubernetes",
  apis: [
    createApiFactory({
      api: kubernetesApiRef,
      deps: {
        discoveryApi: discoveryApiRef,
        identityApi: identityApiRef,
        kubernetesAuthProvidersApi: kubernetesAuthProvidersApiRef
      },
      factory: ({ discoveryApi, identityApi, kubernetesAuthProvidersApi }) => new KubernetesBackendClient({
        discoveryApi,
        identityApi,
        kubernetesAuthProvidersApi
      })
    }),
    createApiFactory({
      api: kubernetesProxyApiRef,
      deps: {
        kubernetesApi: kubernetesApiRef
      },
      factory: ({ kubernetesApi }) => new KubernetesProxyClient({
        kubernetesApi
      })
    }),
    createApiFactory({
      api: kubernetesAuthProvidersApiRef,
      deps: {
        gitlabAuthApi: gitlabAuthApiRef,
        googleAuthApi: googleAuthApiRef,
        microsoftAuthApi: microsoftAuthApiRef,
        oktaAuthApi: oktaAuthApiRef,
        oneloginAuthApi: oneloginAuthApiRef
      },
      factory: ({
        gitlabAuthApi,
        googleAuthApi,
        microsoftAuthApi,
        oktaAuthApi,
        oneloginAuthApi
      }) => {
        const oidcProviders = {
          gitlab: gitlabAuthApi,
          google: googleAuthApi,
          microsoft: microsoftAuthApi,
          okta: oktaAuthApi,
          onelogin: oneloginAuthApi
        };
        return new KubernetesAuthProviders({
          microsoftAuthApi,
          googleAuthApi,
          oidcProviders
        });
      }
    }),
    createApiFactory({
      api: kubernetesClusterLinkFormatterApiRef,
      deps: { googleAuthApi: googleAuthApiRef },
      factory: (deps) => {
        const formatters = getDefaultFormatters(deps);
        return new KubernetesClusterLinkFormatter({
          formatters,
          defaultFormatterName: DEFAULT_FORMATTER_NAME
        });
      }
    })
  ],
  routes: {
    entityContent: rootCatalogKubernetesRouteRef
  }
});
const EntityKubernetesContent = kubernetesPlugin.provide(
  createRoutableExtension({
    name: "EntityKubernetesContent",
    component: () => Promise.resolve().then(function () { return Router$1; }).then((m) => m.Router),
    mountPoint: rootCatalogKubernetesRouteRef
  })
);

const KubernetesContent = ({
  entity,
  refreshIntervalMs
}) => {
  var _a;
  const { kubernetesObjects, error } = useKubernetesObjects(
    entity,
    refreshIntervalMs
  );
  const clustersWithErrors = (_a = kubernetesObjects == null ? void 0 : kubernetesObjects.items.filter((r) => r.errors.length > 0)) != null ? _a : [];
  const detectedErrors = kubernetesObjects !== void 0 ? detectErrors(kubernetesObjects) : /* @__PURE__ */ new Map();
  return /* @__PURE__ */ React.createElement(DetectedErrorsContext.Provider, { value: [...detectedErrors.values()].flat() }, /* @__PURE__ */ React.createElement(Page, { themeId: "tool" }, /* @__PURE__ */ React.createElement(Content, null, kubernetesObjects === void 0 && error === void 0 && /* @__PURE__ */ React.createElement(Progress, null), clustersWithErrors.length > 0 && /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 3, direction: "column" }, /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(
    ErrorPanel,
    {
      entityName: entity.metadata.name,
      clustersWithErrors
    }
  ))), error !== void 0 && /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 3, direction: "column" }, /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(
    ErrorPanel,
    {
      entityName: entity.metadata.name,
      errorMessage: error
    }
  ))), kubernetesObjects && /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 3, direction: "column" }, /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(ErrorReporting, { detectedErrors })), /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(Typography, { variant: "h3" }, "Your Clusters")), /* @__PURE__ */ React.createElement(Grid, { item: true, container: true }, (kubernetesObjects == null ? void 0 : kubernetesObjects.items.length) <= 0 && /* @__PURE__ */ React.createElement(
    Grid,
    {
      container: true,
      justifyContent: "space-around",
      direction: "row",
      alignItems: "center",
      spacing: 2
    },
    /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 8 }, /* @__PURE__ */ React.createElement(
      EmptyState,
      {
        missing: "data",
        title: "No Kubernetes resources",
        description: `No resources on any known clusters for ${entity.metadata.name}`
      }
    ))
  ), (kubernetesObjects == null ? void 0 : kubernetesObjects.items.length) > 0 && (kubernetesObjects == null ? void 0 : kubernetesObjects.items.map((item, i) => {
    var _a2;
    const podsWithErrors = new Set(
      (_a2 = detectedErrors.get(item.cluster.name)) == null ? void 0 : _a2.filter((de) => de.sourceRef.kind === "Pod").map((de) => de.sourceRef.name)
    );
    return /* @__PURE__ */ React.createElement(Grid, { item: true, key: i, xs: 12 }, /* @__PURE__ */ React.createElement(
      Cluster,
      {
        clusterObjects: item,
        podsWithErrors
      }
    ));
  })))))));
};

const KUBERNETES_ANNOTATION = "backstage.io/kubernetes-id";
const KUBERNETES_LABEL_SELECTOR_QUERY_ANNOTATION = "backstage.io/kubernetes-label-selector";
const isKubernetesAvailable = (entity) => {
  var _a, _b;
  return Boolean((_a = entity.metadata.annotations) == null ? void 0 : _a[KUBERNETES_ANNOTATION]) || Boolean(
    (_b = entity.metadata.annotations) == null ? void 0 : _b[KUBERNETES_LABEL_SELECTOR_QUERY_ANNOTATION]
  );
};
const Router = (props) => {
  var _a, _b;
  const { entity } = useEntity();
  const kubernetesAnnotationValue = (_a = entity.metadata.annotations) == null ? void 0 : _a[KUBERNETES_ANNOTATION];
  const kubernetesLabelSelectorQueryAnnotationValue = (_b = entity.metadata.annotations) == null ? void 0 : _b[KUBERNETES_LABEL_SELECTOR_QUERY_ANNOTATION];
  if (kubernetesAnnotationValue || kubernetesLabelSelectorQueryAnnotationValue) {
    return /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(
      Route,
      {
        path: "/",
        element: /* @__PURE__ */ React.createElement(
          KubernetesContent,
          {
            entity,
            refreshIntervalMs: props.refreshIntervalMs
          }
        )
      }
    ));
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(MissingAnnotationEmptyState, { annotation: KUBERNETES_ANNOTATION }), /* @__PURE__ */ React.createElement("h1", null, "Or use a label selector query, which takes precedence over the previous annotation."), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "primary",
      href: "https://backstage.io/docs/features/kubernetes/configuration#surfacing-your-kubernetes-components-as-part-of-an-entity"
    },
    "Read Kubernetes Plugin Docs"
  ));
};

var Router$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isKubernetesAvailable: isKubernetesAvailable,
  Router: Router
});

export { EntityKubernetesContent, Router, isKubernetesAvailable, kubernetesPlugin, kubernetesPlugin as plugin };
//# sourceMappingURL=index.esm.js.map
